# This file is part of COùòïCEPT, the cosmological ùòï-body code in Python.
# Copyright ¬© 2015‚Äì2021 Jeppe Mosgaard Dakin.
#
# COùòïCEPT is free software: You can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# COùòïCEPT is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with COùòïCEPT. If not, see https://www.gnu.org/licenses/
#
# The author of COùòïCEPT can be contacted at dakin(at)phys.au.dk
# The latest version of COùòïCEPT is available at
# https://github.com/jmd-dk/concept/



# This is the main makefile for the COùòïCEPT code.
# You typically do not need to interact with this file directly,
# but instead use the concept script to build and run the code.
# This makefile accepts the option
#   build
# which sets the build directory.

# Use the Bash shell
SHELL = /usr/bin/env bash



##############################
# Specification of filenames #
##############################
# List of files and directories in the util directory
# generated by using the utilities.
files_util =   \
    update_new \



###############################################
# Environment information from the .path file #
###############################################
# Get the path to the .path file
path_filename = $(shell                             \
    search() {                                      \
        for path in $(MAKEFILE_LIST); do            \
            path="$$(readlink -f "$${path}")";      \
            path="$$(dirname "$${path}")";          \
            while [ "$${path}" != "/" ]; do         \
                if [ -f "$${path}/.path" ]; then    \
                    path_filename="$${path}/.path"; \
                    echo "$${path_filename}";       \
                    return;                         \
                fi;                                 \
                path="$$(dirname "$${path}")";      \
            done;                                   \
        done;                                       \
    };                                              \
    search;                                         \
)
ifeq ($(path_filename),)
    $(error Could not find the .path file)
endif
# Include (absolute) paths from the .path file
include $(path_filename)
# Read in the paths
paths = $(shell grep -o '.*=' $(path_filename) | sed 's/.$$//')



#############
# Functions #
#############
# Function for displaying headings based on the value
# of the 'building' variable.
define heading
    $(python) -B -c "pass;                                                         \
        import sys;                                                                \
        sys.exit() if '$(heading_printed)' else None;                              \
        import re;                                                                 \
        import blessings;                                                          \
        extra = [];                                                                \
        extra.append('native optimizations')                                       \
            if '$(native_optimizations)' == 'True'                                 \
                and '$(no_optimizations)' != 'True'                                \
            else None;                                                             \
        extra.append('no link time optimizations')                                 \
            if '$(no_lto)' == 'True'                                               \
                and '$(no_optimizations)' != 'True'                                \
            else None;                                                             \
        extra.append('no optimizations')                                           \
            if '$(no_optimizations)' == 'True'                                     \
            else None;                                                             \
        extra.append('unsafe')                                                     \
            if '$(unsafe_building)' == 'True'                                      \
            else None;                                                             \
        extra.append('serially')                                                   \
            if re.search(r'^ *(-j|--j|--jo|--job|--jobs)=? *1$$', '$(make_jobs)')  \
            else None;                                                             \
        extra = (' (' + ', '.join(extra) + ')')                                    \
            if extra                                                               \
            else '';                                                               \
        terminal = blessings.Terminal(force_styling=True);                         \
        print(terminal.bold_yellow('\nBuilding $(building)' + extra), flush=True); \
    "
    $(eval heading_printed = True)
    sleep 0.05
endef
# Function which takes in one or more quoted or unquoted arguments.
# If these are paths (perhaps prefixed with e.g. -I) located near
# the current directory, the return value is the relative path.
# Otherwise, the return value is just the untouched argument.
sensible_path = $(shell                                                    \
    depth=2;                                                               \
    slow_but_general=False;                                                \
    if [ -n "$2" ]; then                                                   \
        cd "$2";                                                           \
    fi;                                                                    \
    current_dir="$$(pwd)";                                                 \
    print_str="";                                                          \
    for path in $1; do                                                     \
        for prefix in "-I" "-L" "-Wl,-rpath=" ""; do                       \
            if [[ "$${path}" == "$${prefix}"* ]]; then                     \
                n=$$(echo "$${prefix}" | awk '{print length}');            \
                path="$${path:$${n}}";                                     \
                break;                                                     \
            fi;                                                            \
        done;                                                              \
        if [ "$${slow_but_general}" == "True" ]; then                      \
            suffix="";                                                     \
            n=$$(echo "$${path}" | awk '{print length - 1}');              \
            end="$${path:$${n}:1}";                                        \
            if [ "$${end}" == "/" ]; then                                  \
                suffix="/";                                                \
            fi;                                                            \
            path="$$(readlink -m "$${path}")$${suffix}";                   \
        else                                                               \
            if [ "$${path:0:1}" != "/" ]; then                             \
                print_str="$${print_str} $${prefix}$${path}";              \
                continue;                                                  \
            fi;                                                            \
        fi;                                                                \
        if [ "$${path}" == "$${current_dir}" ]; then                       \
            path=".";                                                      \
        elif [[ "$${path}" == "$${current_dir}/"* ]]; then                 \
            n=$$(echo "$${current_dir}" | awk '{print length + 1}');       \
            path="$${path:$${n}}";                                         \
        else                                                               \
            back="";                                                       \
            upper_dir="$${current_dir}";                                   \
            for ((i = 0; i < $${depth}; i += 1)); do                       \
                upper_dir="$$(dirname "$${upper_dir}")";                   \
                if [ "$${path}" == "$${upper_dir}" ]; then                 \
                    path="..$${back}";                                     \
                    break;                                                 \
                elif [[ "$${path}" == "$${upper_dir}/"* ]]; then           \
                    n=$$(echo "$${upper_dir}" | awk '{print length + 1}'); \
                    path="..$${back}/$${path:$${n}}";                      \
                    break;                                                 \
                fi;                                                        \
                back="$${back}/..";                                        \
            done;                                                          \
        fi;                                                                \
        print_str="$${print_str} $${prefix}$${path}";                      \
    done;                                                                  \
    print_str="$$(echo $${print_str})";                                    \
    echo "$${print_str}";                                                  \
)
# Function for eliminating duplicates
define unique
$(shell $(python) -B -c "pass;
    import re;
    unique_word_patterns = {r'^-D', r'^-I', r'^-L', r'^-O', r'^-W', r'^-l'};
    words = [word for word in '$1'.split() if word];
    words_prev = set();
    words = [(word, words_prev.add(word))[0] for word in words if not word in words_prev
        or not any(re.search(pattern, word) for pattern in unique_word_patterns)
    ];
    print(' '.join(words));
")
endef



##############################
# Checks and transformations #
##############################
# Check whether the Python interpreter works.
# Error out if not.
python_test = $(shell $(python) -B -c "print('success')")
ifneq ($(python_test),success)
    $(error Try sourcing the concept script)
endif
# Transform all the included paths to sensible paths
# to reduce screen clutter when building.
$(foreach path,$(paths),$(eval $(path)=$(call sensible_path,$($(path)))))
# If no $(build) directory is defined, use the default build_dir
ifeq ($(build),)
    build = $(build_dir)
endif



###########
# Targets #
###########
# For building the code in the $(build) directory
all:
	@mkdir -p "$(build)"
	@for f_src in "$(src_dir)"/*; do                                       \
	    f_base="$$(basename "$${f_src}")";                                 \
	    f_build="$(build)/$${f_base}";                                     \
	    if [ -f "$${f_build}" ]; then                                      \
	        t_src=$$(stat -c '%Y' "$${f_src}");                            \
	        t_build=$$(stat -c '%Y' "$${f_build}");                        \
	        [ "$${t_build}" -le "$${t_src}" ] || continue;                 \
	    fi;                                                                \
	    cp "$${f_src}" "$${f_build}";                                      \
	    if [ "$${f_base}" == "Makefile" ]; then                            \
	        Makefile="$$(readlink -f "$${concept_dir}")/Makefile";         \
	        sed -i "s/\.\.\/Makefile/$${Makefile//\//\\/}/" "$${f_build}"; \
	    fi;                                                                \
	done
	@$(MAKE) -C "$(build)" --no-print-directory
.PHONY: all
# For building the documentation
doc:
	@$(MAKE) -C "$(doc_dir)" --no-print-directory
.PHONY: doc
# For printing makefile variables
print_vars:
	$(foreach var, $(.VARIABLES), $(info $(var) = $($(var))))
.PHONY: print_vars



###################
# Cleanup targets #
###################
.PHONY:                  \
    clean                \
    clean_autosave       \
    clean_doc            \
    clean_ic             \
    clean_job            \
    clean_output         \
    clean_reusable       \
    clean_class_reusable \
    clean_ewald_reusable \
    clean_fftw_reusable  \
    clean_test           \
    clean_tmp            \
    clean_util           \
    distclean            \
    distclean_except_tmp \

# Remove build files
clean:
	$(RM) -r $(build_dir)
# Remove files generated via autosave
clean_autosave:
	$(RM) $(ic_dir)/autosave_*
	$(RM) $(param_dir)/autosave_*
# Remove documentation build
clean_doc:
	@$(MAKE) -C $(doc_dir) clean_sphinx --no-print-directory
# Remove everything in the ic directory
clean_ic:
	$(RM) -r $(ic_dir)/* $(ic_dir)/.[^.]*
# Remove everything in the job directory
clean_job:
	$(RM) -r $(job_dir)/* $(job_dir)/.[^.]*
# Remove everything in the output directory
clean_output:
	$(RM) -r $(output_dir)/* $(output_dir)/.[^.]*
# Remove reusable dumps
clean_reusable:
	$(RM) -r $(reusable_dir)
clean_class_reusable:
	$(RM) -r $(reusable_dir)/class
clean_ewald_reusable:
	-$(RM) -r $(reusable_dir)/ewald
clean_fftw_reusable:
	$(RM) -r $(reusable_dir)/fftw
# Remove files produced by running tests
clean_test:
	$(foreach clean_file,$(wildcard $(test_dir)/*/clean),$(clean_file);)
# Remove files produced by the utilities
clean_util:
	$(RM) -r $(addprefix $(util_dir)/,$(files_util))
# Remove the tmp directory, generated by various scripts
clean_tmp:
	$(RM) -r $(tmp_dir)
# Remove all unnecessary files,
# leaving COùòïCEPT in a distribution ready state.
# Note that no files in the ic or output directory will be removed,
# and that only auto-generated files will be removed from the
# param directory.
distclean_except_tmp: \
    clean             \
    clean_autosave    \
    clean_doc         \
    clean_job         \
    clean_reusable    \
    clean_test        \
    clean_util        \

distclean: distclean_except_tmp clean_tmp

